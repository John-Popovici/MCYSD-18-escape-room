"""Malware Lab room implementation."""

import json
from typing import override

from escaperoom.rooms.base import Base, RoomInput, RoomOutput
from escaperoom.transcript import TranscriptLogger
from escaperoom.utils import item_to_str


class Malware(Base):
    """A room presenting a process tree graph traversal challenge."""

    @override
    def __init__(
        self,
        transcript_logger: TranscriptLogger,
        data_path: str,
    ) -> None:
        """Initialize the Malware Lab room."""
        super().__init__(
            name="Malware Lab",
            short_name="malware",
            desc="A process graph flickers; " +
            "exfil hides behind an innocent chain.",
            items=["proc_tree.jsonl"],
            files=[f"{data_path}proc_tree.jsonl"],
        )
        self.transcript_logger=transcript_logger
        self.inspected_file = False

    @override
    def interact(self, room_input: RoomInput) -> RoomOutput:
        """Implement game command: inspect, use, interact."""
        if room_input.command[1] == "proc_tree.jsonl":
            # Ensure interaction only happens once
            if self.inspected_file:
                return RoomOutput(
                    success=False,
                    message="This has already been inspected.\n",
                )

            # Solve the room challenge
            output_str: str = "Building graph...\n"
            [item_name, item_data] = self.solve(self.files[0])
            output_str += item_to_str(item_name, item_data)

            # Add data to inventory
            room_input.inventory[item_name] = item_data

            self.inspected_file = True
            return RoomOutput(
                success=True,
                message=output_str,
            )
        return super().interact(room_input)

    @override
    def hint(self, room_input: RoomInput) -> RoomOutput:
        """Implement game command: hint."""
        output_str: str = ""
        if self.inspected_file:
            output_str += "You have everything you need from this room.\n"
        else:
            output_str += ("You feel there is something in " +
            "this room to inspect.\n")
        return RoomOutput(
            success=True,
            message=output_str,
        )

    def solve(self, file_path: str) -> tuple[str, dict[str, str]]:
        """Solves the room challenge."""
        with open(file_path, encoding="utf-8") as f:
            content: str = f.read()

        # Parse all processes
        processes = [
            json.loads(line)
            for line in content.splitlines()
            if line.strip()
        ]

        # Build parent->children map and pid->info lookup
        children = {}
        proc_map = {p["pid"]: p for p in processes}

        for proc in processes:
            ppid = proc["ppid"]
            if ppid not in children:
                children[ppid] = []
            children[ppid].append(proc["pid"])

        # Find root process
        root_pid = next(p["pid"] for p in processes if p["ppid"] == 0)

        # Run DFS search
        found, path, cmd = self.dfs(root_pid, [], set(), proc_map, children)

        if found:
            return (
                "PID",
                {
                    "TOKEN": str(path[-1]),
                    "PATH": "->".join(map(str, path)),
                    "CMD": cmd,
                },
            )

        return ("PID", {"TOKEN": "NOT_FOUND", "PATH": "", "CMD": ""})

    def is_malicious(self, cmd: str) -> bool:
        """Check if command is exfiltrating data."""
        if "curl" in cmd and ("-X POST" in cmd or "-d @" in cmd):
            return True

        return bool("scp" in cmd and ("@" in cmd or ":" in cmd))

    def dfs(self, pid: int, path: list[int], visited: set[int],
            proc_map: dict, children: dict) -> tuple[bool, list[int], str]:
        """Search for malicious command, return (found?, path, command)."""
        if pid in visited:
            return False, [], ""

        visited.add(pid)
        current_path = [*path, pid]
        cmd = proc_map[pid]["cmd"]

        # Found malicious command?
        if self.is_malicious(cmd):
            return True, current_path, cmd

        # Search children
        for child_pid in children.get(pid, []):
            found, result_path, result_cmd = self.dfs(
                child_pid, current_path, visited, proc_map, children,
            )
            if found:
                return True, result_path, result_cmd

        return False, [], ""
